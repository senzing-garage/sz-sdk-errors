#! /usr/bin/env python3

"""
Used to generate csharp/SzExceptionMapper.cs
"""

import json
import logging
import os
from datetime import datetime, timezone

INPUT_FILE = "szerrors.json"
OUTPUT_FILE = "csharp/SzExceptionMapper.cs"
PAD_CLASS = 35


def spaces_not_tabs():
    """Because tabs are used in OUTPUT_HEADER, linters get confused with spaces vs. tabs.  This solves it."""


# -----------------------------------------------------------------------------
# --- Main
# -----------------------------------------------------------------------------

# Set up logging.

logging.basicConfig(format="%(asctime)s %(message)s", level=logging.INFO)

logging.info("-" * 80)
logging.info("--- %s - Begin", os.path.basename(__file__))
logging.info("-" * 80)

# Create multi-line strings for output.

OUTPUT_HEADER = """/*
DO NOT EDIT.  This code is generated.
Generated by: sz-sdk-errors/bin/generate_csharp.py
Generated for: sz-sdk-csharp/Senzing.Sdk/core/SzExceptionMapper.cs
"""

OUTPUT_HEADER += f"Generated date: {datetime.now(timezone.utc).isoformat()}\n"
OUTPUT_HEADER += """ */

using System;
using System.Collections.Generic;

namespace Senzing.Sdk.Core
{
    /// <summary>
    /// Package-access class for dictionaryping Senzing error code to
    /// instances of <see cref="SzException"/>.
    /// </summary>
    internal static class SzExceptionMapper
    {
        /// <summary>
        /// Obtains the exception class for the specified error code.
        /// </summary>
        ///
        /// <param name="dictionary">
        /// The <see cref="System.Collections.Generic.IDictionary{TKey, TValue}"/>
        /// to which to add the mappings of error code keys and exception types.
        /// </param>
        public static void RegisterExceptions(IDictionary<long, Type> dictionary)
        {
"""


OUTPUT_FOOTER = """        }
    }
}
"""

with open(INPUT_FILE, encoding="utf-8") as input_file:
    errors = json.load(input_file)

with open(OUTPUT_FILE, "w", encoding="utf-8") as file:
    file.write(OUTPUT_HEADER)
    for error_number, error_data in errors.items():
        OUTPUT_LINE = ""
        error_class = error_data.get("class")
        if error_class:
            exception_class = error_class.replace("Error", "Exception")
            OUTPUT_LINE = f"            dictionary.Add({error_number}L, typeof({exception_class}));"
            error_name = error_data.get("name")
            error_comment = error_data.get("comment")
            if error_name or error_comment:
                pad_class_len = len(error_number) + len(exception_class)
                OUTPUT_LINE += (
                    " " * (PAD_CLASS - pad_class_len)
                ) + f'  // {error_name:<85} "{error_comment}"'
        if len(OUTPUT_LINE) > 0:
            OUTPUT_LINE += "\n"
            file.write(OUTPUT_LINE)
    file.write(OUTPUT_FOOTER)

# Epilog.

logging.info("-" * 80)
logging.info("--- %s - End", os.path.basename(__file__))
logging.info("-" * 80)
